Filename: deck.cpp
------------------
Deck::Deck () {
}

void
Deck::shuffle () {
    std::random_device rd;
    std::mt19937 g (rd ());
    std::shuffle (cards.begin (), cards.end (), g);
}

void
Deck::generate_deck () {
    for (const auto &suit : suits)
        for (const auto &value : values)
            cards.push_back (value + suit + ";");
}

void
Deck::destroy_deck () {
    cards.clear ();
}

std::string
Deck::deal_card () {
    if (cards.empty ()) {
        return "";
    }
    std::string card = cards.back ();
    cards.pop_back ();
    return card;
}


Filename: deck.hpp
------------------

class Deck {
  public:
    Deck ();

    void shuffle ();
    std::string deal_card ();

    void generate_deck ();
    void destroy_deck ();

  private:
    std::vector<std::string> suits  = {"♡", "♢", "♧", "♤"};
    std::vector<std::string> values = {"A", "2", "3",  "4", "5", "6", "7",
                                       "8", "9", "10", "J", "Q", "K"};
    std::vector<std::string> cards;
};

#endif // DECK_H


Filename: main.cpp
------------------

int
main (int argc, char *argv[]) {
    int id = atoi (argv[1]);
    std::string if_name = argv[2];
    std::string next_id_ip = argv[3];
    std::string prev_id_ip = argv[4];

    Player player (id, if_name, next_id_ip, prev_id_ip);

    std::cout << "Tentando conectar..." << std::endl;
    while (!player.node.connect ())
        player.node.receive_frame ();

    // A quantidade de rodadas é também a quantidade de cartas iniciais do jogo.
    int round = 2;
    while (round) {
        int lap_count = round;
        player.deal_hands (round);
        player.collect_guess ();
        player.display_guesses ();

        while (lap_count > 0) {
            player.collect_plays ();
            player.compute_lap ();
            lap_count--;
        }

        bool keep_playing = player.compute_hp ();
        if (!keep_playing)
            break;

        round -= 1;
    }
    player.check_winner ();

    return 0;
}


Filename: player.cpp
------------------

constexpr int PLAYER_QTT      = 4;
constexpr int ONE_SURVIVOR    = 3;
constexpr bool KEEP_LISTENING = true;
constexpr bool KEEP_PLAYING   = true;

Player::Player (int id, std::string &if_name, std::string &next_id_ip,
                std::string &prev_id_ip)
    : node (id, if_name, next_id_ip, prev_id_ip), id (id), dead (false), guesses (4), plays (4), hp (4, 1) {
    dealer_id   = 0;
    last_winner = 0;
}

// Quebra a string recebida do carteador com as cartas do jogador e as armazena
// no vetor de cartas do jogador.
void
Player::receive_cards (const std::string &cards_string) {
    std::stringstream card_stream (cards_string);
    std::string card;

    while (std::getline (card_stream, card, ';')) {
        if (!card.empty ())
            hand.push_back (card);
    }
}

void
Player::display_cards () {
    std::string cards_str = "";
    for (const auto &card : hand) {
        cards_str += card + ", ";
    }
    if (!cards_str.empty () && cards_str.length () >= 2) {
        cards_str.erase (cards_str.length () - 2);
    }
    std::cout << "Suas cartas são: " << cards_str << std::endl;
}

void
Player::promote_dealer () {
    if (!is_dealer ()) {
        node.receive_frame (KEEP_LISTENING);
        std::string buffer_data = node.get_buffer_data ();
        std::cout << buffer_data << std::endl;
        dealer_id =
            std::stoi (buffer_data.substr (buffer_data.find_last_of (" ") + 1));

        node.receive_frame (!KEEP_LISTENING);
        if (is_dealer ()) {
            buffer_data = node.get_buffer_data ();
            update_hp_array (buffer_data);
        }

        return;
    }

    dealer_id = (dealer_id + 1) % PLAYER_QTT;
    std::string message =
        "O novo carteador é o jogador " + std::to_string (dealer_id) + ".\n";
    node.broadcast_message (message);

    std::string hp_msg = "";
    for (int i = 0; i < 4; i++) {
        hp_msg += std::to_string (hp[i]) + ";";
    }
    node.send_message (hp_msg, dealer_id);
}

bool
Player::is_dealer () {
    return id == dealer_id;
}

int
Player::player_id () {
    return id;
}

void
Player::collect_guess () {
    std::string message, guess, current_guesses;

    if (!is_dealer ()) {
        std::cout << "Esperando os demais jogadores...\n" << std::endl;
        node.receive_frame (KEEP_LISTENING);
        current_guesses = node.get_buffer_data ();
    }

    message = current_guesses;
    if (!dead) {
        guess = handle_guess ();
        message += std::to_string (id) + ":" + guess + ";";
    }

    node.send_coll_message (message);
}

std::string
Player::handle_guess () {
    std::string input;
    display_cards ();
    while (true) {
        std::cout << "Quantas jogadas você acha que vai fazer nessa rodada?"
                  << std::endl;

        std::getline (std::cin, input);
        if (input == "/cartas" || input == "/c") {
            display_cards ();
            continue;
        } else if (std::cin.fail () || !isdigit (input[0]) ||
                   static_cast<unsigned int> (stoi (input)) > hand.size ()) {
            std::cout << "Palpite inválido. O palpite precisa ser um número, e "
                         "o valor precisa ser menor que sua "
                         "quantidade de cartas ("
                      << hand.size ()
                      << ") e maior que zero. Tente novamente.\n"
                      << std::endl;
            continue;
        }

        std::cout << std::endl;
        return input;
    }
}


void
Player::display_guesses () {
    node.receive_frame (!is_dealer ());
    std::string buffer_data = node.get_buffer_data ();
    if (!is_dealer ()) {
        std::cout << buffer_data << std::endl;
        return;
    }

    std::stringstream buffer_stream (buffer_data);
    std::string entry;
    while (std::getline (buffer_stream, entry, ';')) {
        size_t colon_pos = entry.find (':');
        if (colon_pos != std::string::npos) {
            int index         = std::stoi (entry.substr (0, colon_pos));
            std::string value = entry.substr (colon_pos + 1);
            guesses[index]    = stoi (value);
        }
    }

    std::string broadcast_msg = "Nessa rodada, os palpites foram:\n";
    for (int i = 0; i < 4; i++) {
        if (hp[i] > 0)
            broadcast_msg += "Jogador " + std::to_string (i) + ": " +
                             std::to_string (guesses[i]) + "\n";
    }

    node.broadcast_message (broadcast_msg);
}

void
Player::collect_plays () {
    std::string message, buffer_data;
    bool is_last_winner = id == last_winner;
    if (!is_last_winner) {
        std::cout << "Esperando os demais jogadores...\n" << std::endl;
        node.receive_frame (KEEP_LISTENING);
        buffer_data = node.get_buffer_data ();
        std::cout << "\nCartas jogadas:" << std::endl;
        std::cout << buffer_data << std::endl;
    }

    message = buffer_data;
    if (!dead) {
        std::string card = pick_card ();

        message += "O jogador " + std::to_string (id) + " jogou a carta " +
                   card + ".\n";
    }

    node.send_coll_message (message);
    std::cout << "Esperando os demais jogadores...\n" << std::endl;

    if (is_last_winner && !is_dealer ()) {
        node.receive_frame (KEEP_LISTENING);
        buffer_data = node.get_buffer_data ();
        std::cout << "Passando as cartas para o carteador computar o "
                     "ganhador da jogada...\n"
                  << std::endl;
        node.send_message (buffer_data, dealer_id);
    }
}

void
Player::compute_lap () {
    std::string buffer_data, entry, broadcast_msg;

    node.receive_frame (!is_dealer ());
    buffer_data = node.get_buffer_data ();
    if (!is_dealer ()) {
        std::cout << buffer_data << std::endl;
        last_winner = get_winner_from_buffer (buffer_data);

        return;
    }

    std::pair<int, int> current_lap_winner = {-1, 0};
    bool draw{false};

    std::stringstream buffer_stream (buffer_data);
    while (std::getline (buffer_stream, entry)) {
        std::size_t card_pos = entry.find ("carta ") + 6;
        char value_char      = entry[card_pos];
        int value;
        value = translate_value (value_char);
        if (value > current_lap_winner.second) {
            std::size_t player_pos = entry.find ("jogador ") + 8;
            int player             = entry[player_pos] - '0';
            draw                   = false;
            current_lap_winner     = {player, value};
        } else if (value == current_lap_winner.second) {
            draw = true;
        }
    }

    if (!draw) {
        broadcast_msg = "O jogador " +
                        std::to_string (current_lap_winner.first) +
                        " fez a jogada!\n";
        plays[current_lap_winner.first] += 1;
        last_winner = current_lap_winner.first;
    } else {
        broadcast_msg = "Houve um empate. Ninguém fez a jogada.\n";
    }

    node.broadcast_message (broadcast_msg);
}

std::string
Player::pick_card () {
    display_cards ();
    while (true) {
        std::cout << "Qual carta você gostaria de jogar?" << std::endl;
        std::string input;
        std::getline (std::cin, input);
        if (input == "/cartas" || input == "/c") {
            display_cards ();
            continue;
        }

        if (input.size () < 2) {
            std::cerr << "Input menor que o tamanho mínimo. Tente novamente.\n"
                      << std::endl;
            continue;
        }

        // Se o valor da carta é 10 ou "as", ocupa um caractere a mais.
        int substr_divisor =
            (input[0] == '1' || input.substr (0, 2) == "as") ? 2 : 1;
        std::string card_value = input.substr (0, substr_divisor);
        if (std::isalpha (card_value[0])) {
            card_value[0] = std::toupper (card_value[0]);
            card_value    = card_value.substr (0, 1);
        }

        // Remove espaços para caso o jogador escreva o naipe por extenso
        std::string suit = input.substr (substr_divisor);
        if (suit.size () > 3 && suit.substr (0, 3) == " de") {
            suit = suit.substr (4);
        }

        auto it = suits_map.find (suit);
        if (it == suits_map.end ()) {
            std::cerr << "Naipe não reconhecido. Tente novamente.\n"
                      << std::endl;
            continue;
        }

        std::string card = card_value + it->second;

        auto card_it = std::find (hand.begin (), hand.end (), card);
        if (card_it == hand.end ()) {
            std::cerr
                << "Você não possui esta carta na sua mão. Tente novamente.\n"
                << std::endl;
            continue;
        }

        hand.erase (card_it);
        std::cout << "\nVocê jogou a carta " << card << "." << std::endl;

        return card;
    }
}

int
Player::get_winner_from_buffer (std::string &buffer_data) {
    std::size_t player_pos = buffer_data.find ("jogador ");
    if (player_pos != std::string::npos) {
        player_pos += 8;
        return buffer_data[player_pos] - '0';
    }

    // Se não encontrou "jogador" no buffer, o último vencedor continua
    // começando a jogada.
    return last_winner;
}

std::string
Player::generate_hand (int round) {
    std::string hand = "";
    for (int j = 0; j < round; j++)
        hand += deck.deal_card ();

    if (!hand.empty () && hand.back () == ';') {
        hand.pop_back ();
    }

    return hand;
}

void
Player::deal_hands (int round) {
    if (!is_dealer ()) {
        node.receive_frame (KEEP_LISTENING);
        receive_cards (node.get_buffer_data ());
        return;
    }

    deck.generate_deck ();
    // deck.shuffle ();

    for (int i = (id + 1) % NODE_QTT; i != id; i = (i + 1) % NODE_QTT) {
        if (hp[i] <= 0) {
            node.send_message ("", i, true);
            continue;
        }

        std::string hand = generate_hand (round);

        std::cout << "Entregando cartas ao jogador " << i << "..." << std::endl;
        node.send_message (hand, i, true);
    }

    std::string hand = generate_hand (round);
    std::cout << "Entregando cartas ao jogador " << id << ".\n" << std::endl;
    receive_cards (hand);

    deck.destroy_deck ();
}

int
Player::translate_value (char ch) {
    return value_map[ch];
}

bool
Player::compute_hp () {
    std::string buffer_data;
    if (!is_dealer ()) {
        node.receive_frame (KEEP_LISTENING);
        buffer_data = node.get_buffer_data ();
        bool game_ended = buffer_data.find ("end_game") != std::string::npos;
        std::cout << buffer_data.substr (0, buffer_data.find ("end_game"))
                  << std::endl;
        if (game_ended) {
            return !KEEP_PLAYING;
        }
        if (!dead)
            dead = check_death (buffer_data);

        promote_dealer ();

        return KEEP_PLAYING;
    }

    dead_count = 0;
    std::string broadcast_msg =
        "Ao fim desta rodada, as vidas dos jogadores eram:\n";
    for (int i = 0; i < 4; i++) {
        int damage    = std::abs (guesses[i] - plays[i]);
        bool is_alive = hp[i] > 0;

        hp[i] = std::max (0, hp[i] - damage);

        broadcast_msg += "Jogador " + std::to_string (i) + ": ";
        if (is_alive) {
            broadcast_msg += std::to_string (hp[i]) + " (Disse que ganharia " +
                             std::to_string (guesses[i]) + ", e ganhou " +
                             std::to_string (plays[i]) + ", perdendo ";
            if (hp[i] > 0) {
                broadcast_msg += std::to_string (damage) + " vidas.)\n";
            } else {
                broadcast_msg += "suas últimas vidas.)\n";
            }
        } else {
            broadcast_msg += "0 (O jogador não participou desta rodada.)\n";
        }

        if (hp[i] <= 0) {
            dead_count++;
        }
    }

    if (dead_count >= 3) {
        broadcast_msg += "end_game";
    }
    dead = hp[id] <= 0;
    node.broadcast_message (broadcast_msg);
    if (dead_count >= 3) {
        return !KEEP_PLAYING;
    }
    promote_dealer ();
    return KEEP_PLAYING;
}

bool
Player::check_death (std::string &buffer_data) {
    int my_hp = std::stoi (buffer_data.substr (
        buffer_data.find ("Jogador " + std::to_string (id)) + 11, 2));
    return my_hp <= 0;
}

void
Player::update_hp_array (std::string &buffer_data) {
    std::stringstream buffer_stream (buffer_data);
    std::string hp_str;
    int count = 0;
    while (std::getline (buffer_stream, hp_str, ';')) {
        hp[count] = std::stoi (hp_str);
        ++count;
    }
}

void
Player::check_winner () {
    if (!is_dealer ()) {
        node.receive_frame (KEEP_LISTENING);
        std::string buffer_data = node.get_buffer_data ();
        std::cout << buffer_data << std::endl;

        return;
    }

    std::string broadcast_msg = "A partida acabou! ";

    if (dead_count == PLAYER_QTT) {
        broadcast_msg += "Todos os jogadores morreram, não houve vencedor.";
    } else if (dead_count == ONE_SURVIVOR) {
        for (int i = 0; i < 4; ++i) {
            if (hp[i] > 0) {
                broadcast_msg +=
                    "O jogador " + std::to_string (i) + " é o vencedor!";
                break;
            }
        }
    } else {
        evaluate_winner (broadcast_msg);
    }

    node.broadcast_message (broadcast_msg);
}

void
Player::evaluate_winner (std::string &broadcast_msg) {
    int highest_hp     = 0;
    int current_winner = -1;
    bool draw          = false;

    for (int i = 0; i < 4; ++i) {
        if (hp[i] > 0) {
            if (hp[i] > highest_hp) {
                highest_hp     = hp[i];
                current_winner = i;
                draw           = false;
            } else if (hp[i] == highest_hp) {
                draw = true;
            }
        }
    }

    if (draw) {
        announce_draw (broadcast_msg, highest_hp);
    } else {
        broadcast_msg +=
            "O jogador " + std::to_string (current_winner) + " é o vencedor!";
    }
}

void
Player::announce_draw (std::string &broadcast_msg, int highest_hp) {
    broadcast_msg += "Houve um empate entre os jogadores ";
    for (int i = 0; i < 4; ++i) {
        if (hp[i] == highest_hp) {
            broadcast_msg += std::to_string (i) + ", ";
        }
    }
    // Remove the last ", " and add "!"
    broadcast_msg.erase (broadcast_msg.size () - 2);
    broadcast_msg += "!";
}


Filename: player.hpp
------------------
#ifndef PLAYER_H
#define PLAYER_H

#include "deck.hpp"
#include "ring_node.hpp"
#include <string>
#include <vector>

class Player {
  public:
    Player (int id, std::string &ifname, std::string &next_id_ip,
            std::string &prev_id_ip);
    Deck deck;
    RingNode node;

    void receive_cards (const std::string &card);
    void promote_dealer ();
    bool is_dealer ();
    void display_cards ();
    void display_guesses ();
    void collect_guess ();
    int player_id ();
    void deal_hands (int round);
    int hand_size ();
    bool is_hand_empty ();
    std::string pick_card ();
    void collect_plays ();
    void compute_lap ();
    bool compute_hp ();
    void check_winner ();
    void announce_single_survivor (std::string &broadcast_msg);
    void evaluate_winner (std::string &broadcast_msg);
    void announce_draw (std::string &broadcast_msg, int highest_hp);

  private:
    int id;
    int dealer_id;
    int last_winner;
    bool dead;
    int dead_count;
    std::string ifname;

    int translate_value (char ch);
    int get_winner_from_buffer (std::string &buffer_data);
    std::string handle_guess ();
    bool is_between ();
    bool check_death (std::string &buffer_data);
    void update_hp_array (std::string &buffer_data);

    std::string generate_hand (int round);
    std::vector<std::string> hand;
    std::vector<int> guesses;
    std::vector<int> plays;
    std::vector<int> hp;
    std::unordered_map<std::string, std::string> suits_map = {
        {"p",      "♧"}, {"o",      "♢"}, {"c",      "♡"}, {"e",      "♤"}, {"paus",   "♧"}, {"ouro",   "♢"}, {"copas",  "♡"}, {"espada", "♤"}
    };

    // Tabela hash para tratar as cartas A, 10, J, Q e K. Os demais valores são
    // apenas para simplificar a chamada;
    std::unordered_map<char, int> value_map = {
        {'A', 1 }, {'1', 10}, {'J', 11}, {'Q', 12}, {'K', 13}, {'2', 2 }, {'3', 3 }, {'4', 4 }, {'5', 5 }, {'6', 6 }, {'7', 7 }, {'8', 8 }, {'9', 9 },
    };
};

#endif // PLAYER_H


Filename: ring_node.cpp
------------------

RingNode::RingNode (int id, std::string &if_name, std::string &next_id_ip,
                    std::string &prev_id_ip)
    : id (id), next_id ((id + 1) % NODE_QTT), prev_id ((id + 3) % NODE_QTT),
      next_id_ip (next_id_ip), prev_id_ip (prev_id_ip) {

    std::string inet_addr_str = get_ipv4_addr (if_name);
    addr_len                  = sizeof (struct sockaddr_in);

    socket_fd = socket (AF_INET, SOCK_DGRAM, 0);
    if (socket_fd < 0)
        handle_error (ERR_SCKFD_DEF);

    memset (&node_addr, 0, sizeof (node_addr));
    memset (buffer, 0, sizeof (BUFFER_SIZE));
    memset (buffer_data, 0, sizeof (DATA_SIZE));

    node_addr.sin_family = AF_INET;
    node_addr.sin_port   = htons (BASE_PORT + id);
    if (inet_pton (AF_INET, inet_addr_str.c_str (), &node_addr.sin_addr) <= 0)
        handle_error (ERR_INVALID_ADDRESS);

    if (bind (socket_fd, (const struct sockaddr *)&node_addr,
              sizeof (node_addr)) < 0)
        handle_error (ERR_SCKFD_BIND);

    initialize_neighbour_addresses ();
}

std::string
RingNode::get_ipv4_addr (const std::string &if_name) {
    struct ifaddrs *ifaddr, *ifa;
    int family, s;
    char host[NI_MAXHOST];
    const char *interface_name = if_name.c_str ();

    if (getifaddrs (&ifaddr) == -1) {
        handle_error (ERR_GET_IFADDR);
    }

    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == NULL)
            continue;

        family = ifa->ifa_addr->sa_family;

        if (family == AF_INET && strcmp (ifa->ifa_name, interface_name) == 0) {
            s = getnameinfo (ifa->ifa_addr, sizeof (struct sockaddr_in), host,
                             NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
            if (s != 0) {
                handle_error (ERR_GET_NAMEINFO);
            }

            freeifaddrs (ifaddr);
            return host;
        }
    }

    freeifaddrs (ifaddr);
    handle_error (ERR_GET_IFADDR);
    return "";
}

void
RingNode::initialize_neighbour_addresses () {
    memset (&next_addr, 0, sizeof (next_addr));
    memset (&prev_addr, 0, sizeof (prev_addr));

    next_addr.sin_family = AF_INET;
    next_addr.sin_port   = htons (BASE_PORT + next_id);
    next_addr.sin_addr.s_addr = inet_addr (next_id_ip.c_str ());

    prev_addr.sin_family = AF_INET;
    prev_addr.sin_port   = htons (BASE_PORT + prev_id);
    prev_addr.sin_addr.s_addr = inet_addr (prev_id_ip.c_str ());
}

void
RingNode::forward_receipt () {
    buffer[DEST_OFFSET]        = buffer[SRC_OFFSET];
    buffer[SRC_OFFSET]         = id;
    buffer[OPCODE_OFFSET]      = OPC_RECEIPT;
    buffer[FRAME_STATE_OFFSET] = 1;
    set_buffer_data ("");
    forward_frame ();
}

void
RingNode::forward_frame (bool log_message) {
    compute_crc ();
    sendto (socket_fd, buffer, BUFFER_SIZE, 0,
            (const struct sockaddr *)&next_addr, sizeof (next_addr));

    if (log_message) {
        std::cout << "Forwarded frame: '" << buffer + DATA_OFFSET << "' to "
                  << inet_ntop (AF_INET, &(next_addr.sin_addr), next_addr_str,
                                INET_ADDRSTRLEN)
                  << ":" << BASE_PORT + next_id << std::endl;
    }
}

bool
RingNode::check_integrity () {
    return compute_crc (true);
}

bool
RingNode::compute_crc (bool is_dest) {
    int len  = BUFFER_SIZE - 1; // Remove o byte de crc da conta
    char crc = 0xff;
    for (int i = 0; i < len; i++) {
        crc ^= buffer[i];
        for (int j = 0; j < 8; j++) {
            if ((crc & 0x80) != 0)
                crc = (crc << 1) ^ 0x49;
            else
                crc <<= 1;
        }
    }

    if (is_dest)
        return crc == buffer[CRC_OFFSET];

    buffer[CRC_OFFSET] = crc;
    return true;
}

void
RingNode::receive_frame (bool keep_listening) {
    do {
        int msg_len = recvfrom (socket_fd, buffer, BUFFER_SIZE, 0,
                                (struct sockaddr *)&prev_addr, &addr_len);
        buffer[msg_len] = '\0';

        if (!check_integrity ()) {
            std::cout << "CRC error" << std::endl;
            handle_error (ERR_CRC_FAIL);
        } else if (check_dest ()) {
            operation_decoder (buffer[OPCODE_OFFSET]);
            keep_listening = false;
        } else {
            forward_frame ();
        }
    } while (keep_listening);
}

bool
RingNode::check_dest () {
    bool is_dest = id == buffer[DEST_OFFSET];
    return is_dest;
}

int
RingNode::connect () {
    bool last_node      = id == 3;
    buffer[DEST_OFFSET] = (id + 1) % NODE_QTT;
    buffer[SRC_OFFSET]  = id;

    if (!strcmp (buffer + DATA_OFFSET, RING_LOCK)) {
        std::cout << "A rede em anel foi completamente estabelecida.\n"
                  << std::endl;
        if (!last_node)
            forward_frame ();
        return CONN_SUCCESS;
    }

    buffer[OPCODE_OFFSET] = OPC_NOP;

    if (id == 0)
        set_buffer_data ("0");
    sprintf (buffer + DATA_OFFSET + id, "%d", id);

    compute_crc ();

    forward_frame ();

    return CONN_FAIL;
}

int
RingNode::handle_error (const int err_code) {
    // if (err_code == ERR_CRC_FAIL)
    //   call_func(OPC_RESEND);
    auto it = error_map.find (err_code);
    if (it != error_map.end ()) {
        std::cerr << "ERROR: " << it->second << std::endl;
        return it->first;
    }

    std::cerr << "ERROR: Unknown error happened." << std::endl;
    exit (EXIT_FAILURE);
}

void
RingNode::set_buffer_data (std::string data) {
    size_t data_size = std::min (data.size (), static_cast<size_t> (DATA_SIZE));
    memset (buffer + DATA_OFFSET, 0, DATA_SIZE); // Limpa o lixo da parte de dados
    memcpy (buffer + DATA_OFFSET, data.c_str (), data_size);
}

void
RingNode::operation_decoder (char opcode) {
    if (opcode == OPC_NOP)
        return;

    auto it = op_code_map.find (opcode);
    if (it == op_code_map.end ()) {
        handle_error (ERR_INVALID_OPCODE);
    }

    (this->*(it->second)) ();
}

void
RingNode::receive_message () {
    int src_id           = buffer[SRC_OFFSET];
    int distance         = (id - src_id + NODE_QTT) % NODE_QTT;
    int forwarding_count = NODE_QTT - distance - 1;

    bool is_broadcast = buffer[OPCODE_OFFSET] == OPC_BROADCAST;

    if (is_broadcast) {
        char saved_buffer_data[DATA_SIZE];
        memcpy (saved_buffer_data, buffer + DATA_OFFSET, DATA_SIZE);

        forward_receipt ();

        for (int i = 0; i < forwarding_count; i++)
            receive_frame (false);

        memcpy (buffer_data, saved_buffer_data, DATA_SIZE);
    } else {
        memcpy (buffer_data, buffer + DATA_OFFSET, DATA_SIZE);
        forward_receipt ();
    }
}

void
RingNode::receive_coll_message () {
    memcpy (buffer_data, buffer + DATA_OFFSET, DATA_SIZE);
}

std::string
RingNode::get_buffer_data () {
    return std::string (buffer_data);
}

void
RingNode::send_message (std::string message, char dest_node,
                        bool is_broadcast) {
    set_buffer_data (message);
    if (dest_node == id) {
        memcpy (buffer_data, buffer, DATA_SIZE);
        return;
    }
    buffer[OPCODE_OFFSET] = is_broadcast ? OPC_BROADCAST : OPC_MSG;
    buffer[DEST_OFFSET]   = dest_node;
    buffer[SRC_OFFSET]    = id;

    memcpy (last_sent_buffer, buffer, BUFFER_SIZE);
    forward_frame ();
    receive_frame ();
}

void
RingNode::send_coll_message (std::string message) {
    buffer[OPCODE_OFFSET] = OPC_COLL_MSG;
    buffer[DEST_OFFSET]   = next_id;
    buffer[SRC_OFFSET]    = id;

    set_buffer_data (message);
    memcpy (last_sent_buffer, buffer, BUFFER_SIZE);
    forward_frame ();
}

void
RingNode::check_framestate () {
    auto state = buffer[FRAME_STATE_OFFSET];
    if (state != FRAME_RECEIVED) {
        memcpy (buffer, last_sent_buffer, BUFFER_SIZE);
        forward_frame ();
    } else {
        buffer[FRAME_STATE_OFFSET] = FRAME_RESET;
    }
}

void
RingNode::broadcast_message (std::string message) {
    for (int i = next_id; i != id; i = (i + 1) % NODE_QTT) {
        send_message (message, i, true);
    }

    std::cout << message.substr (0, message.find ("end_game")) << std::endl;
}


Filename: ring_node.hpp
------------------

class RingNode {
  public:
    RingNode (int id, std::string &if_name, std::string &next_id_ip,
              std::string &prev_id_ip);
    int connect ();
    void operation_decoder (char opcode);
    void send_message (std::string message, char dest_node,
                       bool is_broadcast = false);
    void send_coll_message (std::string message);
    void forward_frame (bool log_message = false);
    void receive_frame (bool keep_listening = true);
    std::string get_buffer_data ();
    void debug ();
    int get_next_id ();
    void broadcast_message (std::string message);
    void pass_token (char dest_node);

  private:
    std::string get_ipv4_addr (const std::string &if_name);

    unsigned int calculate_neighbour_addr (int neighbour_id);
    void initialize_neighbour_addresses ();

    void forward_receipt ();

    void call_func ();

    void set_buffer_data (std::string data);

    void debug_message (char target);
    void receive_message ();
    void receive_coll_message ();

    bool check_integrity ();
    bool check_dest ();
    bool compute_crc (bool is_dest = false);

    void check_framestate ();

    int handle_error (const int err_code);

    const int id, next_id, prev_id;
    std::string next_id_ip, prev_id_ip;
    int socket_fd;
    struct sockaddr_in node_addr, next_addr, prev_addr;
    char buffer[BUFFER_SIZE];
    char buffer_data[DATA_SIZE];
    char last_sent_buffer[BUFFER_SIZE];
    char next_addr_str[INET_ADDRSTRLEN];
    char prev_addr_str[INET_ADDRSTRLEN];
    socklen_t addr_len;

    std::unordered_map<int, void (RingNode::*) ()> op_code_map = {
        {OPC_MSG,       &RingNode::receive_message     },
        {OPC_BROADCAST, &RingNode::receive_message     },
        {OPC_COLL_MSG,  &RingNode::receive_coll_message},
        {OPC_RECEIPT,   &RingNode::check_framestate    },
    };

    std::unordered_map<int, std::string> error_map = {
        {ERR_INVALID_ADDRESS, "Endereço inválido."               },
        {ERR_SCKFD_BIND,      "Falha ao vincular o socket."      },
        {ERR_SCKFD_DEF,       "Falha ao abrir o socket."         },
        {ERR_GET_IFADDR,      "Nenhuma interface foi encontrada."},
        {ERR_GET_NAMEINFO,    "Falha ao obter o nome do host."   },
    };
};

#endif // RINGNODE_H
